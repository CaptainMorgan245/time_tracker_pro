// lib/employee_repository.dart

import 'package:sqflite/sqflite.dart';
import 'package:time_tracker_pro/database_helper.dart';
import 'package:time_tracker_pro/models.dart';
import 'package:time_tracker_pro/models/analytics_models.dart';
import 'package:flutter/foundation.dart'; // for debugPrint

class EmployeeRepository {
  // Use the V2 instance to get access to the notifier.
  final _databaseHelper = DatabaseHelperV2.instance;
  //final _settingsService = SettingsService.instance;

  // THIS METHOD IS CORRECTED TO PREVENT THE 'no such column' CRASH.
  // No other part of the file has been changed.
  Future<int> insertEmployee(Employee employee) async {
    final db = await _databaseHelper.database;
    int newEmployeeId = -1; // This will hold the auto-generated ID from the database.

    // Use a transaction to ensure all steps succeed or none do. This prevents data corruption.
    await db.transaction((txn) async {
      // Step 1: Get the next available employee NUMBER from the 'settings' table.
      final List<Map<String, dynamic>> settings = await txn.query(
        'settings',
        columns: ['next_employee_number'],
        limit: 1,
      );

      if (settings.isEmpty) {
        throw Exception("CRITICAL: Settings table is not initialized. Cannot generate new employee ID.");
      }

      // This is the number for the user-facing Employee ID string (e.g., "EMP-101").
      final int nextNumber = settings.first['next_employee_number'] as int;

      // The database's primary key 'id' and the user-facing 'employeeNumber' are different.
      // The database will handle the 'id' automatically because it is AUTOINCREMENT.
      // We will generate the user-facing 'employeeNumber' string.
      String employeeNumberToSave = employee.employeeNumber ?? '';
      if (employeeNumberToSave.isEmpty) {
        final List<Map<String, dynamic>> settingsForPrefix = await txn.query(
          'settings',
          columns: ['employee_number_prefix'],
          limit: 1,
        );
        final String prefix = settingsForPrefix.first['employee_number_prefix'] as String? ?? '';
        employeeNumberToSave = '$prefix$nextNumber'; // CORRECTED: Was '$prefix$nextId'.
      }

      // Step 2: Create a copy of the employee object. The 'id' field is left null
      // so the database can assign its own unique, auto-incrementing primary key.
      final newEmployee = employee.copyWith(
        employeeNumber: employeeNumberToSave,
      );

      // Step 3: Insert the new employee. The 'insert' method returns the auto-generated primary key ID.
      newEmployeeId = await txn.insert(
        'employees',
        newEmployee.toMap(),
        // Using replace is safe here because the primary key is generated by the database,
        // so it will always be a new insert.
        conflictAlgorithm: ConflictAlgorithm.replace,

      );

      // Step 4: Increment and update the next_employee_number in the 'settings' table for the *next* employee.
      await txn.update(
        'settings',
        {'next_employee_number': nextNumber + 1},
        where: 'id = ?',
        whereArgs: [1], // Assuming settings table has a single row with id = 1.
      );
    });

    // After the transaction is successfully completed, notify the app that the data has changed.
    _databaseHelper.notifyDatabaseChanged();

    // Return the auto-generated ID of the employee that was just created.
    return newEmployeeId;
  }

  Future<List<EmployeeSummaryViewModel>> fetchEmployeeSummaries() async {
    final db = await _databaseHelper.database;
    // Correcting the SQL query to fit your schema
    List<Map<String, dynamic>> summaries = await db.rawQuery('''
    SELECT 
      e.name AS employeeName, 
      e.employee_number AS employeeNumber, 
      r.name AS roleTitle,
      COUNT(DISTINCT t.project_id) AS projectsCount,
      SUM(t.final_billed_duration_seconds / 3600.0) AS totalHours,
      SUM((t.final_billed_duration_seconds / 3600.0) * 
        (CASE p.pricing_model
          WHEN 'hourly' THEN p.billed_hourly_rate
          ELSE 0 END)
      ) AS totalBilledValue
    FROM employees e
    JOIN time_entries t ON e.id = t.employee_id
    JOIN projects p ON t.project_id = p.id
    JOIN roles r ON e.title_id = r.id
    WHERE e.is_deleted = 0
    GROUP BY e.id;
  ''');

    return summaries.map((map) => EmployeeSummaryViewModel(
      employeeName: map['employeeName'],
      employeeNumber: map['employeeNumber'],
      roleTitle: map['roleTitle'],
      projectsCount: map['projectsCount'],
      totalHours: map['totalHours']?.toDouble() ?? 0.0,
      totalBilledValue: map['totalBilledValue']?.toDouble() ?? 0.0,
    )).toList();
  }

  Future<List<Employee>> getEmployees() async {
    final db = await _databaseHelper.database;
    final List<Map<String, dynamic>> maps = await db.query('employees', where: 'is_deleted = 0');
    return List.generate(maps.length, (i) {
      return Employee.fromMap(maps[i]);
    });
  }

  Future<Employee?> getEmployeeById(int id) async {
    final db = await _databaseHelper.database;
    final List<Map<String, dynamic>> maps = await db.query(
      'employees',
      where: 'id = ?',
      whereArgs: [id],
    );
    if (maps.isNotEmpty) {
      return Employee.fromMap(maps.first);
    }
    return null;
  }

  // Custom personnel report based on user filters
  Future<List<Map<String, dynamic>>> getCustomPersonnelReport(CustomReportSettings settings) async {
    final db = await _databaseHelper.database;

    // Build WHERE clause for employee filter
    List<String> whereConditions = ['e.is_deleted = 0'];
    List<dynamic> whereArgs = [];

    if (settings.employeeId != null) {
      whereConditions.add('e.id = ?');
      whereArgs.add(settings.employeeId);
    }

    String whereClause = whereConditions.join(' AND ');

    // Build date range filter for time entries
    String dateFilter = '';
    if (settings.startDate != null || settings.endDate != null) {
      if (settings.startDate != null) {
        dateFilter += ' AND te.start_time >= \'${settings.startDate!.toIso8601String()}\'';
      }
      if (settings.endDate != null) {
        dateFilter += ' AND te.start_time <= \'${settings.endDate!.toIso8601String()}\'';
      }
    }

    // Build SELECT clause based on included fields
    List<String> selectFields = ['e.name AS employee'];

    if (settings.includes['Role & Status'] == true) {
      selectFields.add('r.name AS role');
    }
    if (settings.includes['Projects Assigned'] == true) {
      selectFields.add('COUNT(DISTINCT te.project_id) AS projects_count');
    }
    if (settings.includes['Total Hours Logged'] == true) {
      selectFields.add('SUM(te.final_billed_duration_seconds / 3600.0) AS total_hours');
    }
    if (settings.includes['Total Billed Value'] == true) {
      selectFields.add('SUM((te.final_billed_duration_seconds / 3600.0) * (CASE p.pricing_model WHEN \'hourly\' THEN p.billed_hourly_rate ELSE 0 END)) AS billed_value');
    }

    final query = '''
    SELECT ${selectFields.join(', ')}
    FROM employees e
    LEFT JOIN roles r ON e.title_id = r.id
    LEFT JOIN time_entries te ON e.id = te.employee_id $dateFilter
    LEFT JOIN projects p ON te.project_id = p.id
    WHERE $whereClause
    GROUP BY e.id
    ORDER BY e.name
  ''';

    debugPrint('[CustomPersonnelReport Query] $query');
    debugPrint('[CustomPersonnelReport Args] $whereArgs');

    return await db.rawQuery(query, whereArgs);
  }

  Future<int> updateEmployee(Employee employee) async {
    final db = await _databaseHelper.database;
    final result = await db.update(
      'employees',
      employee.toMap(),
      where: 'id = ?',
      whereArgs: [employee.id],
    );
    // FIX 3: Call the new PUBLIC method to notify listeners.
    _databaseHelper.notifyDatabaseChanged();
    return result;
  }

  Future<int> deleteEmployee(int id) async {
    final db = await _databaseHelper.database;
    // Instead of a hard delete, we'll mark the employee as deleted.
    // This preserves historical data integrity.
    final updatedEmployee = {'is_deleted': 1};
    final result = await db.update(
      'employees',
      updatedEmployee,
      where: 'id = ?',
      whereArgs: [id],
    );

    // FIX 4: Call the new PUBLIC method to notify listeners.
    _databaseHelper.notifyDatabaseChanged();
    return result;
  }
}
